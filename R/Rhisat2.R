#' Generate HISAT2 index
#'
#' This function can be used to call the \code{hisat2-build} binary.
#'
#' All additional arguments in \code{...} are interpreted as additional
#' arguments to the HISAT2 binaries. Any flags are supposed to be represented as
#' logical values (e.g., \code{quiet=TRUE} will be translated into
#' \code{--quiet}). Parameters with additional input are supposed to be
#' character or numeric vectors, and the individual elements are collapsed into
#' a single comma-separated string (e.g., \code{k=2} is translated into \code{-k
#' 2}, \code{bmax=100} into \code{--bmax 100}). Some arguments to the HISAT2
#' binaries will be ignored if they are already handled as explicit function
#' arguments. See the output of \code{hisat2_usage()} and
#' \code{hisat2_build_usage()} for details about available parameters.
#'
#' @param references Character vector. The path to the files containing the
#'   reference sequences from which to build the HISAT2 index.
#' @param outdir Character scalar. The path to the output directory in which to
#'   store the HISAT2 index. If the directory already exists, the function will
#'   throw an error, unless \code{force=TRUE}.
#' @param prefix Character scalar. The prefix to use for the HISAT2 index files.
#' @param force Logical scalar. Whether to force overwriting of \code{outdir}.
#' @param execute Logical scalar. Whether to execute the assembled shell
#'   command. If FALSE, return a string with the command.
#' @param strict Logical scalar. Whether strict checking of input arguments
#'   should be enforced.
#' @param ... Additional arguments passed to the binaries.
#'
#' @author Charlotte Soneson, based on code from Florian Hahne.
#'
#' @export
#'
#' @references
#' Kim D, Langmead B and Salzberg SL. HISAT: a fast spliced aligner with low
#' memory requirements. Nature Methods 12:357-360 (2015).
#'
#' @return If \code{execute} is TRUE, the output generated by calling the
#'   \code{hisat2-build} binary. If \code{execute} is FALSE, the
#'   \code{hisat2-build} command.
#'
#' @examples
#' tmp <- tempdir()
#' refs <- dir(system.file(package="Rhisat2", "extdata/refs"), full=TRUE)
#' x <- hisat2_build(references=refs, outdir=file.path(tmp, "index"),
#'                   force=TRUE)
#' head(x)
#' dir(file.path(tmp, "index"))
#'
hisat2_build <- function(references, outdir, ..., prefix="index",
                         force=FALSE, strict=TRUE, execute=TRUE) {
    if (strict && (!is.character(references) || !all(file.exists(references)))) {
        stop("Argument 'references' has to be a character vector of names ",
             "of existing fasta files for building the sequence index.")
    }
    if (strict && (!is.character(outdir) || length(outdir) != 1)) {
        stop("Argument 'outdir' must be a character scalar giving the output ",
             "directory to store the HISAT2 indices in.")
    }
    if (strict && (file.exists(outdir) && !force)) {
        stop("Directory '", outdir, "' exists. Use 'force=TRUE' to overwrite.")
    }
    dir.create(outdir, recursive=TRUE, showWarnings=FALSE)
    indexPrefix <- shQuote(path.expand(file.path(outdir, prefix)))

    args <- sprintf("%s %s %s", .createFlags(list(...)),
                    paste(shQuote(path.expand(references)), collapse=","),
                    indexPrefix)

    return(invisible(.hisat2Bin("hisat2-build", args, execute=execute)))
}

#' Align reads with HISAT2
#'
#' @param sequences Character vector (for single-end experiments) or list of two
#'   character vectors (for paired-end experiments) of file names of fasta or
#'   fastq files that will be aligned by HISAT2. The character vectors can contain
#'   more than one file name, in which case the reads will be combined across
#'   all the provided files in the corresponding vector.
#' @param index Character scalar, giving the directory where the genome
#'   index is stored.
#' @param type Character scalar, either "single" or "paired", giving the type of
#'   the experiment.
#' @param outfile (optional) Character scalar, the prefix of the
#'   alignment files (including the output directory). If not provided, will be
#'   set to the current directory (\code{./}).
#' @param force Logical scalar, whether or not to overwrite an existing output
#'   directory.
#' @param strict Logical scalar, whether strict checking of input arguments
#'   should be enforced.
#' @param execute Logical scalar, whether to execute the command. If FALSE,
#'   return a string with the shell command.
#' @param ... Additional arguments provided to STAR in the genome index
#'   generation.
#'
#' @author Charlotte Soneson
#'
#' @export
#'
#' @return If \code{execute} is TRUE, invisibly returns the console output of
#'   running the read alignment. If \code{execute} is FALSE, invisibly returns
#'   the shell command.
#'
#' @examples
#' \dontrun{
#' starAlign(readFilesIn="", genomeDir="genome", type="single",
#'           outFileNamePrefix="output/sample1")
#' }
hisat2 <- function(sequences, index, ...,
                   type=c("single", "paired", "crossbow"), outfile,
                   force=FALSE, strict=TRUE, execute=TRUE) {
    type <- match.arg(type)
    args <- list(...)
    args <- args[setdiff(names(args), c("1", "2", "12"))]
    seqIn <- !is.null(args[["c"]]) && args[["c"]]
    seqArg <- ""
    if (strict) {
        seqArg <- switch(
            type,
            single={
                if (!is.character(sequences) ||
                    (!seqIn && !all(file.exists(sequences)))) {
                    stop("Argument 'sequences' has to be a character vector ",
                         "of filenames to align against the bowtie index or ",
                         "a character of read sequences if the additional ",
                         "argument c==TRUE.")
                }
                paste(shQuote(path.expand(sequences)), collapse=",")
            },
            paired={
                if (!is.list(sequences) || length(sequences) != 2) {
                    stop("Argument 'sequences' must be a list of length 2.")
                }
                tmp <- NULL
                for (i in seq_len(2)) {
                    if(!is.character(sequences[[i]]) ||
                       (!seqIn && !all(file.exists(sequences[[i]])))) {
                        stop("Argument 'sequences[[", i, "]]' has to be a ",
                             "character vector of filenames to align ",
                             "against the HISAT2 index or a character of read ",
                             "sequences if the additional argument c==TRUE.")
                    }
                    tmp <- paste(tmp,  "-", i, " ",
                                 paste(shQuote(path.expand(sequences[[i]])),
                                       collapse=","),
                                 " ", sep="")
                }
                tmp
            },
            crossbow={
                if(!is.character(sequences) || (!seqIn && !all(file.exists(sequences))))
                    stop("Argument 'sequences' has to be a character vector of filenames ",
                         "to align against the bowtie index or a character of read ",
                         "sequences if the additional argument c==TRUE.")
                paste("-12 ", paste(shQuote(path.expand(sequences)), collapse=","))
            })

        if (!is.character(index) || !file.exists(dirname(index))) {
            stop("Argument 'index' has to be a character scalar giving ",
                 "the path to the index directory.")
        }
    }
    outfile <- if (!missing(outfile)) {
        if (strict && (!is.character(outfile) || length(outfile) != 1)) {
            stop("Argument 'outfile' must be a character scalar giving the output ",
                 "file name to store the HISAT2 alignments in.")
        }
        if (strict && (file.exists(outfile) && !force)) {
            stop("File '", outfile, "' exists. Use 'force=TRUE' to overwrite.")
        }
        sprintf(" %s", shQuote(path.expand(outfile)))
    } else {
        ""
    }

    args <- sprintf("%s %s %s %s", .createFlags(args),
                    shQuote(path.expand(index)), seqArg, outfile)

    return(invisible(.hisat2Bin("hisat2", args, execute=execute)))
}

hisat2_build_usage <- function() {
    print(.hisat2Bin(bin="hisat2-build", args="--help", execute=TRUE))
}

hisat2_usage <- function() {
    print(.hisat2Bin(bin="hisat2", args="--help", execute=TRUE))
}

hisat2_version <- function() {
    print(.hisat2Bin(bin="hisat2", args="--version", execute=TRUE))
}
